<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>pxar: pxar::api Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">pxar
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepxar.html">pxar</a></li><li class="navelem"><a class="el" href="classpxar_1_1api.html">api</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classpxar_1_1api-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pxar::api Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="api_8h_source.html">api.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a532160655f47df5be07866cd81beff01"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a532160655f47df5be07866cd81beff01">api</a> (std::string usbId=&quot;*&quot;, std::string logLevel=&quot;WARNING&quot;)</td></tr>
<tr class="separator:a532160655f47df5be07866cd81beff01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae058b619d8a296efb9fb3523c0217210"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#ae058b619d8a296efb9fb3523c0217210">~api</a> ()</td></tr>
<tr class="separator:ae058b619d8a296efb9fb3523c0217210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195e13c554408d18bf84930feca5474f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a195e13c554408d18bf84930feca5474f">getVersion</a> ()</td></tr>
<tr class="separator:a195e13c554408d18bf84930feca5474f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc66f74e3811575cc0f27c1924b30f0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#acc66f74e3811575cc0f27c1924b30f0b">initTestboard</a> (std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; sig_delays, std::vector&lt; std::pair&lt; std::string, double &gt; &gt; power_settings, std::vector&lt; std::pair&lt; uint16_t, uint8_t &gt; &gt; pg_setup)</td></tr>
<tr class="separator:acc66f74e3811575cc0f27c1924b30f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4c8d1ffa253910f1118e9f86ddb05d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#aca4c8d1ffa253910f1118e9f86ddb05d">initDUT</a> (std::string tbmtype, std::vector&lt; std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; &gt; tbmDACs, std::string roctype, std::vector&lt; std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; &gt; rocDACs, std::vector&lt; std::vector&lt; <a class="el" href="classpxar_1_1pixelConfig.html">pixelConfig</a> &gt; &gt; rocPixels)</td></tr>
<tr class="separator:aca4c8d1ffa253910f1118e9f86ddb05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815fda43aaf919d5ff08bd4cede81eff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a815fda43aaf919d5ff08bd4cede81eff">programDUT</a> ()</td></tr>
<tr class="separator:a815fda43aaf919d5ff08bd4cede81eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bfc59d3c5fa2d715a17346362f69b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#ae2bfc59d3c5fa2d715a17346362f69b9">flashTB</a> (std::string filename)</td></tr>
<tr class="separator:ae2bfc59d3c5fa2d715a17346362f69b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f835d006cf6588816994960cec35384"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a1f835d006cf6588816994960cec35384">getTBia</a> ()</td></tr>
<tr class="separator:a1f835d006cf6588816994960cec35384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fd66daf14894c4e2d6805fda7f8292"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#ad2fd66daf14894c4e2d6805fda7f8292">getTBva</a> ()</td></tr>
<tr class="separator:ad2fd66daf14894c4e2d6805fda7f8292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c8a5a23ed4ab989c757f0d4b8c6982"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a61c8a5a23ed4ab989c757f0d4b8c6982">getTBid</a> ()</td></tr>
<tr class="separator:a61c8a5a23ed4ab989c757f0d4b8c6982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f04d48fd90d8f7e67a66164cd5a0a66"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a6f04d48fd90d8f7e67a66164cd5a0a66">getTBvd</a> ()</td></tr>
<tr class="separator:a6f04d48fd90d8f7e67a66164cd5a0a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e888286effd8c64df5fe7e3131ee808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a1e888286effd8c64df5fe7e3131ee808">HVoff</a> ()</td></tr>
<tr class="separator:a1e888286effd8c64df5fe7e3131ee808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9251daaf8f35b3736413f49db61c9099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a9251daaf8f35b3736413f49db61c9099">HVon</a> ()</td></tr>
<tr class="separator:a9251daaf8f35b3736413f49db61c9099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0aee46f028230d61eac9a2fc49bdb77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#ad0aee46f028230d61eac9a2fc49bdb77">Pon</a> ()</td></tr>
<tr class="separator:ad0aee46f028230d61eac9a2fc49bdb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac080c3ef5093ff30ca6671f743d6c467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#ac080c3ef5093ff30ca6671f743d6c467">Poff</a> ()</td></tr>
<tr class="separator:ac080c3ef5093ff30ca6671f743d6c467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f307ef8bd741e41277882a48b776eed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a3f307ef8bd741e41277882a48b776eed">SignalProbe</a> (std::string probe, std::string name)</td></tr>
<tr class="separator:a3f307ef8bd741e41277882a48b776eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2957f6c3d26d02d3e856d09a3856e79b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a2957f6c3d26d02d3e856d09a3856e79b">setDAC</a> (std::string dacName, uint8_t dacValue, uint8_t rocid)</td></tr>
<tr class="separator:a2957f6c3d26d02d3e856d09a3856e79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d333941a0f111a34b2e240eb599ed8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a7d333941a0f111a34b2e240eb599ed8d">setDAC</a> (std::string dacName, uint8_t dacValue)</td></tr>
<tr class="separator:a7d333941a0f111a34b2e240eb599ed8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf48a6d4a16873dbe6684e89637cb437"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#abf48a6d4a16873dbe6684e89637cb437">getDACRange</a> (std::string dacName)</td></tr>
<tr class="separator:abf48a6d4a16873dbe6684e89637cb437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67c716a3b55524ec4a9efa67be07b6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#ae67c716a3b55524ec4a9efa67be07b6c">setTbmReg</a> (std::string regName, uint8_t regValue, uint8_t tbmid)</td></tr>
<tr class="separator:ae67c716a3b55524ec4a9efa67be07b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1dbe19cda603d6f6a8e06c320efccc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#aea1dbe19cda603d6f6a8e06c320efccc">setTbmReg</a> (std::string regName, uint8_t regValue)</td></tr>
<tr class="separator:aea1dbe19cda603d6f6a8e06c320efccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a1956543e851feaeeed38358b6d354"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a50a1956543e851feaeeed38358b6d354">getPulseheightVsDAC</a> (std::string dacName, uint8_t dacMin, uint8_t dacMax, uint16_t flags=0, uint16_t nTriggers=16)</td></tr>
<tr class="separator:a50a1956543e851feaeeed38358b6d354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b219465a54a1d12b007df443e71a80"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a54b219465a54a1d12b007df443e71a80">getEfficiencyVsDAC</a> (std::string dacName, uint8_t dacMin, uint8_t dacMax, uint16_t flags=0, uint16_t nTriggers=16)</td></tr>
<tr class="separator:a54b219465a54a1d12b007df443e71a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5917574f7b86210720ff08e6ce0cd766"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a5917574f7b86210720ff08e6ce0cd766">getThresholdVsDAC</a> (std::string dacName, std::string dac2name, uint8_t dac2min, uint8_t dac2max, uint16_t flags=0, uint16_t nTriggers=16)</td></tr>
<tr class="separator:a5917574f7b86210720ff08e6ce0cd766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62c2854ff7acc5c5d40f27107ebe386"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#af62c2854ff7acc5c5d40f27107ebe386">getThresholdVsDAC</a> (std::string dac1name, uint8_t dac1min, uint8_t dac1max, std::string dac2name, uint8_t dac2min, uint8_t dac2max, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:af62c2854ff7acc5c5d40f27107ebe386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4101fd0d62233967c6666b68025c5621"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::pair&lt; uint8_t, <br class="typebreak"/>
std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a4101fd0d62233967c6666b68025c5621">getPulseheightVsDACDAC</a> (std::string dac1name, uint8_t dac1min, uint8_t dac1max, std::string dac2name, uint8_t dac2min, uint8_t dac2max, uint16_t flags=0, uint16_t nTriggers=16)</td></tr>
<tr class="separator:a4101fd0d62233967c6666b68025c5621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcabc6ef5cc215fd815345e723e3c4b6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::pair&lt; uint8_t, <br class="typebreak"/>
std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#adcabc6ef5cc215fd815345e723e3c4b6">getEfficiencyVsDACDAC</a> (std::string dac1name, uint8_t dac1min, uint8_t dac1max, std::string dac2name, uint8_t dac2min, uint8_t dac2max, uint16_t flags=0, uint16_t nTriggers=16)</td></tr>
<tr class="separator:adcabc6ef5cc215fd815345e723e3c4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3579e2e5b15c3446ebeb255df0ecfe7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#af3579e2e5b15c3446ebeb255df0ecfe7">getPulseheightMap</a> (uint16_t flags=0, uint16_t nTriggers=16)</td></tr>
<tr class="separator:af3579e2e5b15c3446ebeb255df0ecfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544c073f3fb6387fce384fab126351f5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a544c073f3fb6387fce384fab126351f5">getEfficiencyMap</a> (uint16_t flags=0, uint16_t nTriggers=16)</td></tr>
<tr class="separator:a544c073f3fb6387fce384fab126351f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d95190e751c99c94b9d441b0dd5cbee"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a0d95190e751c99c94b9d441b0dd5cbee">getThresholdMap</a> (std::string dacName, uint8_t dacMin, uint8_t dacMax, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:a0d95190e751c99c94b9d441b0dd5cbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5968f51ed91af49cc27b30dfa90d2b04"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a5968f51ed91af49cc27b30dfa90d2b04">getThresholdMap</a> (std::string dacName, uint16_t flags=0, uint16_t nTriggers=16)</td></tr>
<tr class="separator:a5968f51ed91af49cc27b30dfa90d2b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1d4721b0d8154be6c5f49e9aab743c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b1d4721b0d8154be6c5f49e9aab743c"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>getReadbackValue</b> (std::string parameterName)</td></tr>
<tr class="separator:a8b1d4721b0d8154be6c5f49e9aab743c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b81df6fa931d29e1a4d52bc7547034"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#ab1b81df6fa931d29e1a4d52bc7547034">daqStart</a> (std::vector&lt; std::pair&lt; uint16_t, uint8_t &gt; &gt; pg_setup)</td></tr>
<tr class="separator:ab1b81df6fa931d29e1a4d52bc7547034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed143f14b8031bbffb6b811e86099441"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#aed143f14b8031bbffb6b811e86099441">daqStatus</a> ()</td></tr>
<tr class="separator:aed143f14b8031bbffb6b811e86099441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b445ef3d6bf1f843fe70c9c53d93498"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpxar_1_1Event.html">Event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a5b445ef3d6bf1f843fe70c9c53d93498">daqGetEvent</a> ()</td></tr>
<tr class="separator:a5b445ef3d6bf1f843fe70c9c53d93498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f5ef5602daa4ae0e0d29d8df9f4536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpxar_1_1rawEvent.html">rawEvent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#af9f5ef5602daa4ae0e0d29d8df9f4536">daqGetRawEvent</a> ()</td></tr>
<tr class="separator:af9f5ef5602daa4ae0e0d29d8df9f4536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae878d6092bce52491ea3866dcc1e450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#aae878d6092bce52491ea3866dcc1e450">daqTrigger</a> (uint32_t nTrig=1)</td></tr>
<tr class="separator:aae878d6092bce52491ea3866dcc1e450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b43798c983e348c801b232e6ac2e683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a3b43798c983e348c801b232e6ac2e683">daqTriggerLoop</a> (uint16_t period=1000)</td></tr>
<tr class="separator:a3b43798c983e348c801b232e6ac2e683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6baafe5b75a1bec7b3c83df05e6a9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a1d6baafe5b75a1bec7b3c83df05e6a9c">daqStop</a> ()</td></tr>
<tr class="separator:a1d6baafe5b75a1bec7b3c83df05e6a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2802fa539743ab7992bac7f6af248b61"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpxar_1_1rawEvent.html">rawEvent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a2802fa539743ab7992bac7f6af248b61">daqGetRawBuffer</a> ()</td></tr>
<tr class="separator:a2802fa539743ab7992bac7f6af248b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104814cc785a1ab0de89472565ddecc4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpxar_1_1Event.html">Event</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a104814cc785a1ab0de89472565ddecc4">daqGetEventBuffer</a> ()</td></tr>
<tr class="separator:a104814cc785a1ab0de89472565ddecc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0345a9e4b0644c5244a9ce508060e663"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a0345a9e4b0644c5244a9ce508060e663">status</a> ()</td></tr>
<tr class="separator:a0345a9e4b0644c5244a9ce508060e663"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a47720382ebbbabf99eb166541cf2bf9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpxar_1_1dut.html">dut</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1api.html#a47720382ebbbabf99eb166541cf2bf9f">_dut</a></td></tr>
<tr class="separator:a47720382ebbbabf99eb166541cf2bf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>pxar API class definition</p>
<p>this is the central API through which all calls from tests and user space functions have to be routed in order to interact with the hardware.</p>
<p>The API level aims to provide a set of high-level function from which the "user" (or test implementation) can choose. This approach allows to hide hardware specific functions and calls from the user space code and automatize e.g. startup procedures.</p>
<p>All input from user space is checked before programming it to the devices. Register addresses have an internal lookup mechanism so the user only hast to provide e.g. the DAC name to be programmed as a string.</p>
<p>Unless otherwise specified (some DAQ functions allow this) all data returned from API functions is fully decoded and stored in C++ structures using std::vectors and std::pairs to ease its handling.</p>
<p>Another concept implemented is the Device Under Test (DUT) which is a class representing the attached hardware to be tested. In order to change its configuration the user space code interacts with the _dut object and alters its settings. This is programmed into the devices automatically before the next test is executed. This approach allows both the efficient execution of many RPC calls at once and reading back the actual device configuration at any time during the tests.</p>
<p>Calls to test functions are automatically expanded in a way that they cover the full device in the most efficient way available. Instead of scanning 4160 pixels after another the code will select the function to scan a full ROC in one go automatically. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a532160655f47df5be07866cd81beff01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">api::api </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>usbId</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>logLevel</em> = <code>&quot;WARNING&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor for the libpxar API</p>
<p>Fetches a new HAL instance and opens the connection to the testboard specified in the "usbId" parameter. An asterisk as "usbId" acts as wildcard. If only one DTB is connected the algorithm will automatically connect to this board, if several are connected it will throw a warning. </p>

</div>
</div>
<a class="anchor" id="ae058b619d8a296efb9fb3523c0217210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">api::~api </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default destructor for libpxar API</p>
<p>Will power down the DTB, disconnect properly from the testboard, and destroy the HAL object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5b445ef3d6bf1f843fe70c9c53d93498"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpxar_1_1Event.html">Event</a> api::daqGetEvent </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read out the earliest <a class="el" href="classpxar_1_1Event.html">Event</a> in buffer from the current data acquisition session. If no <a class="el" href="classpxar_1_1Event.html">Event</a> is buffered, the function will wait for the next <a class="el" href="classpxar_1_1Event.html">Event</a> to arrive and then return it. </p>

</div>
</div>
<a class="anchor" id="a104814cc785a1ab0de89472565ddecc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpxar_1_1Event.html">Event</a> &gt; api::daqGetEventBuffer </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to return the full <a class="el" href="classpxar_1_1Event.html">Event</a> buffer from the testboard RAM after the data acquisition has been stopped. All data is decoded and the function returns decoded pixels separated in Events with additional header information available. </p>

</div>
</div>
<a class="anchor" id="a2802fa539743ab7992bac7f6af248b61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpxar_1_1rawEvent.html">rawEvent</a> &gt; api::daqGetRawBuffer </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to return the full <a class="el" href="classpxar_1_1Event.html">Event</a> buffer from the testboard RAM after the data acquisition has been stopped. No decoding is performed, this function returns the raw data blob from either of the deserializer modules. </p>

</div>
</div>
<a class="anchor" id="af9f5ef5602daa4ae0e0d29d8df9f4536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpxar_1_1rawEvent.html">rawEvent</a> api::daqGetRawEvent </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read out the earliest raw data record in buffer from the current data acquisition session. If no <a class="el" href="classpxar_1_1Event.html">Event</a> is buffered, the function will wait for the next <a class="el" href="classpxar_1_1Event.html">Event</a> to arrive and then return it. </p>

</div>
</div>
<a class="anchor" id="ab1b81df6fa931d29e1a4d52bc7547034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool api::daqStart </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; uint16_t, uint8_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>pg_setup</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to set up and initialize a new data acquisition session (DAQ)</p>
<p>This function takes a new Pattern Generator setup as argument, if left empty the one which is currently programmed via the <a class="el" href="classpxar_1_1api.html#acc66f74e3811575cc0f27c1924b30f0b">api::initTestboard</a> function is used. The given pattern generator only lives for the time of the data acquisition and is replaced by the previous one after stopping the DAQ. </p>

</div>
</div>
<a class="anchor" id="aed143f14b8031bbffb6b811e86099441"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool api::daqStatus </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to get back the DAQ status</p>
<p>For a running DAQ with free buffer memory left, this function returns TRUE. In case of a problem with the DAQ (not started, buffer overflow or full...) it returns FALSE. </p>

</div>
</div>
<a class="anchor" id="a1d6baafe5b75a1bec7b3c83df05e6a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool api::daqStop </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to stop the running data acquisition</p>
<p>This triggers also a reprogramming of the old (test-) Pattern Generator setup, so no additional steps are needed before one can do regular tests again. The patterns are taken from the DUT struct in which they are stored by the <a class="el" href="classpxar_1_1api.html#acc66f74e3811575cc0f27c1924b30f0b">api::initTestboard</a> function. </p>

</div>
</div>
<a class="anchor" id="aae878d6092bce52491ea3866dcc1e450"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void api::daqTrigger </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nTrig</em> = <code>1</code>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to fire the previously defined pattern command list "nTrig" times, the function parameter defaults to 1. </p>

</div>
</div>
<a class="anchor" id="a3b43798c983e348c801b232e6ac2e683"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void api::daqTriggerLoop </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em> = <code>1000</code>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to fire the previously defined pattern command list continuously every "period" clock cycles (default: 1000) </p>

</div>
</div>
<a class="anchor" id="ae2bfc59d3c5fa2d715a17346362f69b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool api::flashTB </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to flash a new firmware onto the DTB via the USB connection. </p>

</div>
</div>
<a class="anchor" id="abf48a6d4a16873dbe6684e89637cb437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t api::getDACRange </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the valid range of a given DAC </p>

</div>
</div>
<a class="anchor" id="a544c073f3fb6387fce384fab126351f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; api::getEfficiencyMap </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to get a map of the efficiency</p>
<p>Returns a vector of pixels, with the value of the pixel struct being the number of hits in that pixel. Efficiency == 1 for nhits == nTriggers </p>

</div>
</div>
<a class="anchor" id="a54b219465a54a1d12b007df443e71a80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; api::getEfficiencyVsDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a DAC range and measure the efficiency</p>
<p>Returns a vector of pairs containing set dac value and pixels, with the value of the pixel struct being the number of hits in that pixel. Efficiency == 1 for nhits == nTriggers </p>

</div>
</div>
<a class="anchor" id="adcabc6ef5cc215fd815345e723e3c4b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; &gt; api::getEfficiencyVsDACDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac1name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac2name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a 2D DAC-Range (DAC1 vs. DAC2) and measure the efficiency</p>
<p>Returns a vector containing pairs of DAC1 values and pais of DAC2 values with a pixel vector. The value of the pixel struct is the number of hits in that pixel. Efficiency == 1 for nhits == nTriggers </p>

</div>
</div>
<a class="anchor" id="af3579e2e5b15c3446ebeb255df0ecfe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; api::getPulseheightMap </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to get a map of the pulse height</p>
<p>Returns a vector of pixels, with the value of the pixel struct being the averaged pulse height over "nTriggers" triggers </p>

</div>
</div>
<a class="anchor" id="a50a1956543e851feaeeed38358b6d354"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; api::getPulseheightVsDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a DAC range and measure the pulse height</p>
<p>Returns a vector of pairs containing set dac value and a pixel vector, with the value of the pixel struct being the averaged pulse height over "nTriggers" triggers </p>

</div>
</div>
<a class="anchor" id="a4101fd0d62233967c6666b68025c5621"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; &gt; api::getPulseheightVsDACDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac1name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac2name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a 2D DAC-Range (DAC1 vs. DAC2) and measure the pulse height</p>
<p>Returns a vector containing pairs of DAC1 values and pais of DAC2 values with a pixel vector. The value of the pixel struct is the averaged pulse height over "nTriggers" triggers. </p>

</div>
</div>
<a class="anchor" id="a1f835d006cf6588816994960cec35384"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double api::getTBia </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read out analog DUT supply current on the testboard</p>
<p>The current will be returned in units of Ampere </p>

</div>
</div>
<a class="anchor" id="a61c8a5a23ed4ab989c757f0d4b8c6982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double api::getTBid </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read out digital DUT supply current on the testboard</p>
<p>The current will be returned in units of Ampere </p>

</div>
</div>
<a class="anchor" id="ad2fd66daf14894c4e2d6805fda7f8292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double api::getTBva </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read out analog DUT supply voltage on the testboard</p>
<p>The voltage will be returned in units of Volts </p>

</div>
</div>
<a class="anchor" id="a6f04d48fd90d8f7e67a66164cd5a0a66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double api::getTBvd </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read out digital DUT supply voltage on the testboard</p>
<p>The voltage will be returned in units of Volts </p>

</div>
</div>
<a class="anchor" id="a0d95190e751c99c94b9d441b0dd5cbee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; api::getThresholdMap </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to get a map of the pixel threshold</p>
<p>Returns a vector of pixels, with the value of the pixel struct being the threshold value of that pixel.</p>
<p>This function allows to specify a range for the threshold DAC to be searched, this can be used to speed up the procedure by limiting the range.</p>
<p>The threshold is calculated as the 0.5 value of the s-curve of the pixel. </p>

</div>
</div>
<a class="anchor" id="a5968f51ed91af49cc27b30dfa90d2b04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; api::getThresholdMap </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to get a map of the pixel threshold</p>
<p>Returns a vector of pixels, with the value of the pixel struct being the threshold value of that pixel.</p>
<p>The threshold is calculated as the 0.5 value of the s-curve of the pixel. </p>

</div>
</div>
<a class="anchor" id="a5917574f7b86210720ff08e6ce0cd766"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; api::getThresholdVsDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac2name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a DAC range and measure the pixel threshold</p>
<p>Returns a vector of pairs containing set dac value and pixels, with the value of the pixel struct being the threshold value of that pixel.</p>
<p>The threshold is calculated as the 0.5 value of the s-curve of the pixel. </p>

</div>
</div>
<a class="anchor" id="af62c2854ff7acc5c5d40f27107ebe386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; api::getThresholdVsDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac1name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac2name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a DAC range and measure the pixel threshold</p>
<p>Returns a vector of pairs containing set dac value and pixels, with the value of the pixel struct being the threshold value of that pixel.</p>
<p>This function allows to specify a range for the threshold DAC to be searched, this can be used to speed up the procedure by limiting the range.</p>
<p>The threshold is calculated as the 0.5 value of the s-curve of the pixel. </p>

</div>
</div>
<a class="anchor" id="a195e13c554408d18bf84930feca5474f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string api::getVersion </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the version string for the pxar API.</p>
<p>When using a git checkout the version number will be calculated at compile time from the latest tagged version plus the number of commits on top of that. In this case the version number also contains the commit hash of the latest commit for reference.</p>
<p>In case of a tarball install the version number is hardcoded in the CMakeLists.txt file. </p>

</div>
</div>
<a class="anchor" id="a1e888286effd8c64df5fe7e3131ee808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void api::HVoff </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>turn off HV </p>

</div>
</div>
<a class="anchor" id="a9251daaf8f35b3736413f49db61c9099"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void api::HVon </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>turn on HV </p>

</div>
</div>
<a class="anchor" id="aca4c8d1ffa253910f1118e9f86ddb05d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool api::initDUT </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tbmtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>tbmDACs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>roctype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>rocDACs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classpxar_1_1pixelConfig.html">pixelConfig</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>rocPixels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializer method for the DUT (attached devices)</p>
<p>This function requires the types and DAC settings for all TBMs and ROCs contained in the setup. All values will be checked for validity (DAC ranges, position and number of pixels, etc.)</p>
<p>All parameters are supplied via vectors, the size of the vector represents the number of devices. DAC names and device types should be provided as strings. The respective register addresses will be looked up internally. Strings are checked case-insensitive, old and new DAC names are both supported. </p>

</div>
</div>
<a class="anchor" id="acc66f74e3811575cc0f27c1924b30f0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool api::initTestboard </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>sig_delays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string, double &gt; &gt;&#160;</td>
          <td class="paramname"><em>power_settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; uint16_t, uint8_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>pg_setup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializer method for the testboard</p>
<p>Initializes the tesboard with signal delay settings, and voltage/current limit settings (power_settings) and the initial pattern generator setup (pg_setup), all provided via vectors of pairs with descriptive name.</p>
<p>The name lookup is performed via the central API dictionaries.</p>
<p>All user inputs are checked for sanity. This includes range checks on the current limits set, a sanity check for the pattern generator command list (including a check for delay = 0 at the end of the list). </p>

</div>
</div>
<a class="anchor" id="ac080c3ef5093ff30ca6671f743d6c467"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void api::Poff </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>turn off power </p>

</div>
</div>
<a class="anchor" id="ad0aee46f028230d61eac9a2fc49bdb77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void api::Pon </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>turn on power </p>

</div>
</div>
<a class="anchor" id="a815fda43aaf919d5ff08bd4cede81eff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool api::programDUT </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Programming method for the DUT (attached devices)</p>
<p>This function requires the DUT structure to be filled (initialized).</p>
<p>All parameters are taken from the DUT struct, the enabled devices are programmed. This function needs to be called after power cycling the testboard output (using Poff, Pon).</p>
<p>A DUT flag is set which prEvents test functions to be executed if not programmed. </p>

</div>
</div>
<a class="anchor" id="a2957f6c3d26d02d3e856d09a3856e79b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool api::setDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rocid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read values from the integrated digital scope on the DTBSet a DAC value on the DUT for one specific ROC</p>
<p>The "rocid" parameter can be used to select a specific ROC to program.</p>
<p>This function will both update the bookkeeping value in the DUT struct and program the actual device. </p>

</div>
</div>
<a class="anchor" id="a7d333941a0f111a34b2e240eb599ed8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool api::setDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a DAC value on the DUT for all enabled ROC</p>
<p>This function will both update the bookkeeping value in the DUT struct and program the actual device. </p>

</div>
</div>
<a class="anchor" id="ae67c716a3b55524ec4a9efa67be07b6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool api::setTbmReg </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>regName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>tbmid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a register value on a specific TBM of the DUT</p>
<p>The "tbmid" parameter can be used to select a specific TBM to program. This function will both update the bookkeeping value in the DUT struct and program the actual device.</p>
<p>This function will set the respective register always in both cores of the TBM specified. </p>

</div>
</div>
<a class="anchor" id="aea1dbe19cda603d6f6a8e06c320efccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool api::setTbmReg </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>regName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a register value on all TBMs of the DUT</p>
<p>This function will both update the bookkeeping value in the DUT struct and program the actual device.</p>
<p>This function will set the respective register always in both cores of all TBMs configured in the DUT. </p>

</div>
</div>
<a class="anchor" id="a3f307ef8bd741e41277882a48b776eed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool api::SignalProbe </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>probe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects "signal" as output for the DTB probe channel "probe" (digital or analog)</p>
<p>The signal identifier is checked against a dictionary to be valid. In case of an invalid signal identifier the output is turned off. </p>

</div>
</div>
<a class="anchor" id="a0345a9e4b0644c5244a9ce508060e663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool api::status </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Status function for the API</p>
<p>Returns true if everything is setup correctly for operation </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a47720382ebbbabf99eb166541cf2bf9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpxar_1_1dut.html">dut</a>* pxar::api::_dut</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DUT object for book keeping of settings </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>core/api/<a class="el" href="api_8h_source.html">api.h</a></li>
<li>core/api/api.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 27 2014 10:36:13 for pxar by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
