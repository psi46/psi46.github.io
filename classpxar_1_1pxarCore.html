<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>pxar: pxar::pxarCore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">pxar
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepxar.html">pxar</a></li><li class="navelem"><a class="el" href="classpxar_1_1pxarCore.html">pxarCore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classpxar_1_1pxarCore-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pxar::pxarCore Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="api_8h_source.html">api.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7268230890d3840456b97d8a8268c236"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a7268230890d3840456b97d8a8268c236">pxarCore</a> (std::string usbId=&quot;*&quot;, std::string logLevel=&quot;WARNING&quot;)</td></tr>
<tr class="separator:a7268230890d3840456b97d8a8268c236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9a015238d5f496746a88a71580f40b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a9b9a015238d5f496746a88a71580f40b">~pxarCore</a> ()</td></tr>
<tr class="separator:a9b9a015238d5f496746a88a71580f40b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebf962f162ccc8334fe7abb469ae603"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a8ebf962f162ccc8334fe7abb469ae603">getVersion</a> ()</td></tr>
<tr class="separator:a8ebf962f162ccc8334fe7abb469ae603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac548bd5277822a2909ebf7bef6a0d43c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ac548bd5277822a2909ebf7bef6a0d43c">initTestboard</a> (std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; sig_delays, std::vector&lt; std::pair&lt; std::string, double &gt; &gt; power_settings, std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; pg_setup)</td></tr>
<tr class="separator:ac548bd5277822a2909ebf7bef6a0d43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090fd82d15bf7ac2a8db2e474e5ecb33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a090fd82d15bf7ac2a8db2e474e5ecb33">setTestboardPower</a> (std::vector&lt; std::pair&lt; std::string, double &gt; &gt; power_settings)</td></tr>
<tr class="separator:a090fd82d15bf7ac2a8db2e474e5ecb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2fffac45525dd53e6f1a211a8f106d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#aea2fffac45525dd53e6f1a211a8f106d">setTestboardDelays</a> (std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; sig_delays)</td></tr>
<tr class="separator:aea2fffac45525dd53e6f1a211a8f106d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3f9fcc5e6de2cd2bd5ac48a9be78d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a1a3f9fcc5e6de2cd2bd5ac48a9be78d1">setPatternGenerator</a> (std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; pg_setup)</td></tr>
<tr class="separator:a1a3f9fcc5e6de2cd2bd5ac48a9be78d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90558c993bd7f1a7bbf0211427fa1883"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a90558c993bd7f1a7bbf0211427fa1883">initDUT</a> (uint8_t hubId, std::string tbmtype, std::vector&lt; std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; &gt; tbmDACs, std::string roctype, std::vector&lt; std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; &gt; rocDACs, std::vector&lt; std::vector&lt; <a class="el" href="classpxar_1_1pixelConfig.html">pixelConfig</a> &gt; &gt; rocPixels, std::vector&lt; uint8_t &gt; rocI2Cs)</td></tr>
<tr class="separator:a90558c993bd7f1a7bbf0211427fa1883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c61cf0cf2622bb154dcc801f2f891c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a67c61cf0cf2622bb154dcc801f2f891c">initDUT</a> (uint8_t hubid, std::string tbmtype, std::vector&lt; std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; &gt; tbmDACs, std::string roctype, std::vector&lt; std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; &gt; rocDACs, std::vector&lt; std::vector&lt; <a class="el" href="classpxar_1_1pixelConfig.html">pixelConfig</a> &gt; &gt; rocPixels)</td></tr>
<tr class="separator:a67c61cf0cf2622bb154dcc801f2f891c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d921d40a156d80066affb1a230c17a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ae5d921d40a156d80066affb1a230c17a">programDUT</a> ()</td></tr>
<tr class="separator:ae5d921d40a156d80066affb1a230c17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0d47aed5d09e863b218719f24c23fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#afd0d47aed5d09e863b218719f24c23fc">flashTB</a> (std::string filename)</td></tr>
<tr class="separator:afd0d47aed5d09e863b218719f24c23fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a1071988d01e6ed626f0ad608d089e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a40a1071988d01e6ed626f0ad608d089e">getTBia</a> ()</td></tr>
<tr class="separator:a40a1071988d01e6ed626f0ad608d089e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6419c0d917bee6cecb59f1e66589ab99"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a6419c0d917bee6cecb59f1e66589ab99">getTBva</a> ()</td></tr>
<tr class="separator:a6419c0d917bee6cecb59f1e66589ab99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b001119e0e60dada88b18341d0ea5c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ab7b001119e0e60dada88b18341d0ea5c">getTBid</a> ()</td></tr>
<tr class="separator:ab7b001119e0e60dada88b18341d0ea5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbcdd46ea90d929e56ed1b5269406158"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#acbcdd46ea90d929e56ed1b5269406158">getTBvd</a> ()</td></tr>
<tr class="separator:acbcdd46ea90d929e56ed1b5269406158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac767ac2ab1365bfe06ee644521632210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ac767ac2ab1365bfe06ee644521632210">HVoff</a> ()</td></tr>
<tr class="separator:ac767ac2ab1365bfe06ee644521632210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24431df2e62c79195cb1ff43a6c5ece1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a24431df2e62c79195cb1ff43a6c5ece1">HVon</a> ()</td></tr>
<tr class="separator:a24431df2e62c79195cb1ff43a6c5ece1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697061c7a1aa2896b2621e217f313bbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a697061c7a1aa2896b2621e217f313bbc">Pon</a> ()</td></tr>
<tr class="separator:a697061c7a1aa2896b2621e217f313bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f141e8cf927b697e405b2067809890"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a13f141e8cf927b697e405b2067809890">Poff</a> ()</td></tr>
<tr class="separator:a13f141e8cf927b697e405b2067809890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376f496a005202e06854393ada0d0cd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a376f496a005202e06854393ada0d0cd7">SignalProbe</a> (std::string probe, std::string name)</td></tr>
<tr class="separator:a376f496a005202e06854393ada0d0cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2351890b0272fff90b8e9fe82a18f8ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2351890b0272fff90b8e9fe82a18f8ec"></a>
std::vector&lt; uint16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>daqADC</b> (std::string signal, uint8_t gain, uint16_t nSample, uint8_t source, uint8_t start)</td></tr>
<tr class="separator:a2351890b0272fff90b8e9fe82a18f8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fad3782f3cd2f76acd6d9ae84e72d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a13fad3782f3cd2f76acd6d9ae84e72d1">setDAC</a> (std::string dacName, uint8_t dacValue, uint8_t rocI2C)</td></tr>
<tr class="separator:a13fad3782f3cd2f76acd6d9ae84e72d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a7a90248e5ca1d21f39911242e22da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a27a7a90248e5ca1d21f39911242e22da">setDAC</a> (std::string dacName, uint8_t dacValue)</td></tr>
<tr class="separator:a27a7a90248e5ca1d21f39911242e22da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccb6f5e5a02459ba7fa7ef9cb6d2a3e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a5ccb6f5e5a02459ba7fa7ef9cb6d2a3e">getDACRange</a> (std::string dacName)</td></tr>
<tr class="separator:a5ccb6f5e5a02459ba7fa7ef9cb6d2a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e6b5ff840d72ccc3bc3cead2b1ab2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ae4e6b5ff840d72ccc3bc3cead2b1ab2d">setTbmReg</a> (std::string regName, uint8_t regValue, uint8_t tbmid)</td></tr>
<tr class="separator:ae4e6b5ff840d72ccc3bc3cead2b1ab2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab616074fb9f630d18ea8d2dba2900695"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ab616074fb9f630d18ea8d2dba2900695">setTbmReg</a> (std::string regName, uint8_t regValue)</td></tr>
<tr class="separator:ab616074fb9f630d18ea8d2dba2900695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71995f1d7d7500cc4f8a9203b3de197a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a71995f1d7d7500cc4f8a9203b3de197a">getPulseheightVsDAC</a> (std::string dacName, uint8_t dacMin, uint8_t dacMax, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:a71995f1d7d7500cc4f8a9203b3de197a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ac879718c4f5712c364ff1b06649bf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ae8ac879718c4f5712c364ff1b06649bf">getPulseheightVsDAC</a> (std::string dacName, uint8_t dacStep, uint8_t dacMin, uint8_t dacMax, uint16_t flags, uint16_t nTrigger)</td></tr>
<tr class="separator:ae8ac879718c4f5712c364ff1b06649bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3347177376e2a7b9e55b68dfacd1d81b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a3347177376e2a7b9e55b68dfacd1d81b">getEfficiencyVsDAC</a> (std::string dacName, uint8_t dacMin, uint8_t dacMax, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:a3347177376e2a7b9e55b68dfacd1d81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae556094df8de36da8293aa7953e11e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a3ae556094df8de36da8293aa7953e11e">getEfficiencyVsDAC</a> (std::string dacName, uint8_t dacStep, uint8_t dacMin, uint8_t dacMax, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:a3ae556094df8de36da8293aa7953e11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e5089712a3c41e7588d852c2f2be6a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a61e5089712a3c41e7588d852c2f2be6a">getThresholdVsDAC</a> (std::string dacName, std::string dac2name, uint8_t dac2min, uint8_t dac2max, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:a61e5089712a3c41e7588d852c2f2be6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfff2fc927e9be3af232e49d3bac511"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a9cfff2fc927e9be3af232e49d3bac511">getThresholdVsDAC</a> (std::string dac1name, uint8_t dac1step, uint8_t dac1min, uint8_t dac1max, std::string dac2name, uint8_t dac2step, uint8_t dac2min, uint8_t dac2max, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:a9cfff2fc927e9be3af232e49d3bac511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d3638feb85989ab781de9210a44a27"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a84d3638feb85989ab781de9210a44a27">getThresholdVsDAC</a> (std::string dac1name, uint8_t dac1step, uint8_t dac1min, uint8_t dac1max, std::string dac2name, uint8_t dac2step, uint8_t dac2min, uint8_t dac2max, uint8_t threshold, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:a84d3638feb85989ab781de9210a44a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9377c701b65b5a4c33213519f84e3b6f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::pair&lt; uint8_t, <br class="typebreak"/>
std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a9377c701b65b5a4c33213519f84e3b6f">getPulseheightVsDACDAC</a> (std::string dac1name, uint8_t dac1min, uint8_t dac1max, std::string dac2name, uint8_t dac2min, uint8_t dac2max, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:a9377c701b65b5a4c33213519f84e3b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13e60b7270ead9f8a2b450341fc7ccf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::pair&lt; uint8_t, <br class="typebreak"/>
std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ab13e60b7270ead9f8a2b450341fc7ccf">getPulseheightVsDACDAC</a> (std::string dac1name, uint8_t dac1step, uint8_t dac1min, uint8_t dac1max, std::string dac2name, uint8_t dac2step, uint8_t dac2min, uint8_t dac2max, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:ab13e60b7270ead9f8a2b450341fc7ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b0b947be9ee0bedf0da497bca023a6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::pair&lt; uint8_t, <br class="typebreak"/>
std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a24b0b947be9ee0bedf0da497bca023a6">getEfficiencyVsDACDAC</a> (std::string dac1name, uint8_t dac1min, uint8_t dac1max, std::string dac2name, uint8_t dac2min, uint8_t dac2max, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:a24b0b947be9ee0bedf0da497bca023a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c91b826614b1c1defd248097846ba8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; uint8_t, std::pair&lt; uint8_t, <br class="typebreak"/>
std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ab5c91b826614b1c1defd248097846ba8">getEfficiencyVsDACDAC</a> (std::string dac1name, uint8_t dac1step, uint8_t dac1min, uint8_t dac1max, std::string dac2name, uint8_t dac2step, uint8_t dac2min, uint8_t dac2max, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:ab5c91b826614b1c1defd248097846ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de11051f5c0babffd3cdef948853012"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a9de11051f5c0babffd3cdef948853012">getPulseheightMap</a> (uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:a9de11051f5c0babffd3cdef948853012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011fa8ad63621ef87e78e341c598310d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a011fa8ad63621ef87e78e341c598310d">getEfficiencyMap</a> (uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:a011fa8ad63621ef87e78e341c598310d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8318cc0578158041a0c43543dfb7e1a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a8318cc0578158041a0c43543dfb7e1a5">getThresholdMap</a> (std::string dacName, uint8_t dacStep, uint8_t dacMin, uint8_t dacMax, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:a8318cc0578158041a0c43543dfb7e1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a94cd47a8305af37702cc605d2579d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a97a94cd47a8305af37702cc605d2579d">getThresholdMap</a> (std::string dacName, uint8_t dacStep, uint8_t dacMin, uint8_t dacMax, uint8_t threshold, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:a97a94cd47a8305af37702cc605d2579d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31ccce6a021b6520e7b357062e8ed57"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ab31ccce6a021b6520e7b357062e8ed57">getThresholdMap</a> (std::string dacName, uint16_t flags, uint16_t nTriggers)</td></tr>
<tr class="separator:ab31ccce6a021b6520e7b357062e8ed57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd08a94f6d99b78a1e5a1f2ec87cbb9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#afd08a94f6d99b78a1e5a1f2ec87cbb9b">setExternalClock</a> (bool enable)</td></tr>
<tr class="separator:afd08a94f6d99b78a1e5a1f2ec87cbb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc60832fc9539864fd2f116d9343aa96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#afc60832fc9539864fd2f116d9343aa96">setClockStretch</a> (uint8_t src, uint16_t delay, uint16_t width)</td></tr>
<tr class="separator:afc60832fc9539864fd2f116d9343aa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e880c5e5f8a450bfe3a613b59b82fcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a5e880c5e5f8a450bfe3a613b59b82fcd">setSignalMode</a> (std::string signal, uint8_t mode)</td></tr>
<tr class="separator:a5e880c5e5f8a450bfe3a613b59b82fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43ae607a6619f2537cf80c508d89241"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ab43ae607a6619f2537cf80c508d89241">daqStart</a> ()</td></tr>
<tr class="separator:ab43ae607a6619f2537cf80c508d89241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7e04e876b8e2d884290916b933266c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf7e04e876b8e2d884290916b933266c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>daqStart</b> (const int bufsize, const bool init)</td></tr>
<tr class="separator:adf7e04e876b8e2d884290916b933266c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad751e6657de4afb09fc4af9bb0a69ca2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ad751e6657de4afb09fc4af9bb0a69ca2">daqStatus</a> ()</td></tr>
<tr class="separator:ad751e6657de4afb09fc4af9bb0a69ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c123f34f3cb7e8e5303887522086453"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a3c123f34f3cb7e8e5303887522086453">daqStatus</a> (uint8_t &amp;perFull)</td></tr>
<tr class="separator:a3c123f34f3cb7e8e5303887522086453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8553ec075197d4ecbba82cb5e552b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpxar_1_1Event.html">Event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#aec8553ec075197d4ecbba82cb5e552b8">daqGetEvent</a> ()</td></tr>
<tr class="separator:aec8553ec075197d4ecbba82cb5e552b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57711da2ef09a67ebca235d5436e224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpxar_1_1rawEvent.html">rawEvent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ae57711da2ef09a67ebca235d5436e224">daqGetRawEvent</a> ()</td></tr>
<tr class="separator:ae57711da2ef09a67ebca235d5436e224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce0621796340ba7c3b5eb9604f4e55a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#acce0621796340ba7c3b5eb9604f4e55a">daqTrigger</a> (uint32_t nTrig=1, uint16_t period=0)</td></tr>
<tr class="separator:acce0621796340ba7c3b5eb9604f4e55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61596d18804c16f0440b67ace220bdd4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a61596d18804c16f0440b67ace220bdd4">daqTriggerLoop</a> (uint16_t period=1000)</td></tr>
<tr class="separator:a61596d18804c16f0440b67ace220bdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd40763a4eeade93be93459f07d9f455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#abd40763a4eeade93be93459f07d9f455">daqTriggerLoopHalt</a> ()</td></tr>
<tr class="separator:abd40763a4eeade93be93459f07d9f455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4a6df644bfb89f8d92b71d30a081d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#aba4a6df644bfb89f8d92b71d30a081d9">daqStop</a> ()</td></tr>
<tr class="separator:aba4a6df644bfb89f8d92b71d30a081d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7130b4eca8e36e1f972fd01c309b89d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7130b4eca8e36e1f972fd01c309b89d7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>daqStop</b> (const bool init)</td></tr>
<tr class="separator:a7130b4eca8e36e1f972fd01c309b89d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad472e54418fbb81f4d509864525ec3a7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpxar_1_1rawEvent.html">rawEvent</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ad472e54418fbb81f4d509864525ec3a7">daqGetRawEventBuffer</a> ()</td></tr>
<tr class="separator:ad472e54418fbb81f4d509864525ec3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691163068f93c9a058fc114086c026ce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a691163068f93c9a058fc114086c026ce">daqGetBuffer</a> ()</td></tr>
<tr class="separator:a691163068f93c9a058fc114086c026ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712515c68f8c6e59de27be48dd412762"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpxar_1_1Event.html">Event</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a712515c68f8c6e59de27be48dd412762">daqGetEventBuffer</a> ()</td></tr>
<tr class="separator:a712515c68f8c6e59de27be48dd412762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa12d6b741deaa921c1c555882cfe230"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector<br class="typebreak"/>
&lt; uint16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#aaa12d6b741deaa921c1c555882cfe230">daqGetReadback</a> ()</td></tr>
<tr class="separator:aaa12d6b741deaa921c1c555882cfe230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f32e86178f7b6141d0b8168dc6d0d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpxar_1_1statistics.html">statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#ac5f32e86178f7b6141d0b8168dc6d0d6">getStatistics</a> ()</td></tr>
<tr class="separator:ac5f32e86178f7b6141d0b8168dc6d0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080862f2b2c399fd09a13c8000daeff5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a080862f2b2c399fd09a13c8000daeff5">status</a> ()</td></tr>
<tr class="separator:a080862f2b2c399fd09a13c8000daeff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545077d25ea75ff6dfb972544b0f4a54"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a545077d25ea75ff6dfb972544b0f4a54">GetADC</a> (uint8_t rpc_par1)</td></tr>
<tr class="separator:a545077d25ea75ff6dfb972544b0f4a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd230c972c6856940049ad719f29a9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#afbd230c972c6856940049ad719f29a9a">SetCalibrateBits</a> (bool enable)</td></tr>
<tr class="separator:afbd230c972c6856940049ad719f29a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3bbaa8cf5eb2bd76411e924952a2081e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpxar_1_1dut.html">dut</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpxar_1_1pxarCore.html#a3bbaa8cf5eb2bd76411e924952a2081e">_dut</a></td></tr>
<tr class="separator:a3bbaa8cf5eb2bd76411e924952a2081e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>pxar API class definition</p>
<p>this is the central API through which all calls from tests and user space functions have to be routed in order to interact with the hardware.</p>
<p>The API level aims to provide a set of high-level function from which the "user" (or test implementation) can choose. This approach allows to hide hardware specific functions and calls from the user space code and automatize e.g. startup procedures.</p>
<p>All input from user space is checked before programming it to the devices. Register addresses have an internal lookup mechanism so the user only hast to provide e.g. the DAC name to be programmed as a std::string.</p>
<p>Unless otherwise specified (some DAQ functions allow this) all data returned from API functions is fully decoded and stored in C++ structures using std::vectors and std::pairs to ease its handling. Most functions will return a std::vector containing <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> elements storing the readout data.</p>
<p>Another concept implemented is the Device Under Test (DUT) which is a class (<a class="el" href="classpxar_1_1dut.html">pxar::dut</a>) representing the attached hardware to be tested. In order to change its configuration the user space code interacts with the _dut object and alters its settings. This is programmed into the devices automatically before the next test is executed. This approach allows both the efficient execution of many RPC calls at once and reading back the actual device configuration at any time during the tests.</p>
<p>Calls to test functions are automatically expanded in a way that they cover the full device in the most efficient way available. Instead of scanning 4160 pixels after another the code will select the function to scan a full ROC in one go automatically. </p>

<p>Definition at line <a class="el" href="api_8h_source.html#l00146">146</a> of file <a class="el" href="api_8h_source.html">api.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7268230890d3840456b97d8a8268c236"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pxarCore::pxarCore </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>usbId</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>logLevel</em> = <code>&quot;WARNING&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor for the libpxar API</p>
<p>Fetches a new pxar::hal instance and opens the connection to the testboard specified in the "usbId" parameter. An asterisk as "usbId" acts as wildcard. If only one DTB is connected the algorithm will automatically connect to this board, if several are connected it will give a warning.</p>
<p>On issues with the USB connection, a <a class="el" href="classpxar_1_1UsbConnectionError.html">pxar::UsbConnectionError</a> is thrown. If the firmware on the DTB does not match the expected version for pxar, a <a class="el" href="classpxar_1_1FirmwareVersionMismatch.html">pxar::FirmwareVersionMismatch</a> exception is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00019">19</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9b9a015238d5f496746a88a71580f40b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pxarCore::~pxarCore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default destructor for libpxar API</p>
<p>Will power down the DTB, disconnect properly from the testboard, and destroy the pxar::hal object. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00038">38</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a691163068f93c9a058fc114086c026ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint16_t &gt; pxarCore::daqGetBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to return the full currently available raw data buffer from the testboard RAM. Neither decoding nor splitting is performed, this function returns the raw data blob from either of the deserializer modules. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01263">1263</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aec8553ec075197d4ecbba82cb5e552b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpxar_1_1Event.html">Event</a> pxarCore::daqGetEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read out the earliest <a class="el" href="classpxar_1_1Event.html">pxar::Event</a> in buffer from the current data acquisition session. If no <a class="el" href="classpxar_1_1Event.html">Event</a> is buffered, the function will wait for the next <a class="el" href="classpxar_1_1Event.html">Event</a> to arrive and then return it.</p>
<p>This function can throw a <a class="el" href="classpxar_1_1DataDecodingError.html">pxar::DataDecodingError</a> exception in case severe problems were encountered during the readout. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01300">1300</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a712515c68f8c6e59de27be48dd412762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpxar_1_1Event.html">Event</a> &gt; pxarCore::daqGetEventBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to return the full currently available <a class="el" href="classpxar_1_1Event.html">pxar::Event</a> buffer from the testboard RAM. All data is decoded and the function returns decoded pixels separated in pxar::Events with additional header information available.</p>
<p>This function can throw a <a class="el" href="classpxar_1_1DataDecodingError.html">pxar::DataDecodingError</a> exception in case severe problems were encountered during the readout. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01285">1285</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae57711da2ef09a67ebca235d5436e224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpxar_1_1rawEvent.html">rawEvent</a> pxarCore::daqGetRawEvent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read out the earliest raw data record in buffer from the current data acquisition session. If no <a class="el" href="classpxar_1_1Event.html">Event</a> is buffered, the function will wait for the next <a class="el" href="classpxar_1_1Event.html">Event</a> to arrive and then return it. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01312">1312</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad472e54418fbb81f4d509864525ec3a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpxar_1_1rawEvent.html">rawEvent</a> &gt; pxarCore::daqGetRawEventBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to return the full currently available raw event buffer from the testboard RAM. No decoding is performed, the data stream is just split into single <a class="el" href="classpxar_1_1rawEvent.html">pxar::rawEvent</a> objects. This function returns the raw events from either of the deserializer modules. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01270">1270</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aaa12d6b741deaa921c1c555882cfe230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; uint16_t &gt; &gt; pxarCore::daqGetReadback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to return the full currently available ROC slow readback value buffer. The data is stored until a new DAQ session or test is called and can be fetched once (deleted at read time). The return vector contains one vector of readback values for every ROC found in the readout chain. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01126">1126</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab43ae607a6619f2537cf80c508d89241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::daqStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to set up and initialize a new data acquisition session (DAQ). This function also programs all attached devices. Pixel configurations which are changed after calling this function will not be written to the devices, so make sure to mask/unmask and set test bits for all pixels in question before calling pxar::daqStart()! </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01139">1139</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ad751e6657de4afb09fc4af9bb0a69ca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::daqStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to get back the DAQ status</p>
<p>For a running DAQ with free buffer memory left, this function returns TRUE. In case of a problem with the DAQ (not started, buffer overflow or full...) it returns FALSE. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01191">1191</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3c123f34f3cb7e8e5303887522086453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::daqStatus </td>
          <td>(</td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>perFull</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same Function as pxar::daqStatus() but provides additional parameter (pass-by-reference) to inform about the current fill status of the DAQ buffer in percent. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01200">1200</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aba4a6df644bfb89f8d92b71d30a081d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::daqStop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to stop the running data acquisition </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01324">1324</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="acce0621796340ba7c3b5eb9604f4e55a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pxarCore::daqTrigger </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nTrig</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to fire the previously defined pattern command list "nTrig" times, the function parameter defaults to 1. The function returns the triggering period actually used after cross-check with the pattern generator cycle length. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01222">1222</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a61596d18804c16f0440b67ace220bdd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pxarCore::daqTriggerLoop </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period</em> = <code>1000</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to fire the previously defined pattern command list continuously every "period" clock cycles (default: 1000) The function returns the triggering period actually used after cross-check with the pattern generator cycle length. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01239">1239</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="abd40763a4eeade93be93459f07d9f455"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pxarCore::daqTriggerLoopHalt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to halt the pattern generator loop which has been started using <a class="el" href="classpxar_1_1pxarCore.html#a61596d18804c16f0440b67ace220bdd4">daqTriggerLoop()</a>. This stops triggering the devices. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01257">1257</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="afd0d47aed5d09e863b218719f24c23fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::flashTB </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to flash a new firmware onto the DTB via the USB connection. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00397">397</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a545077d25ea75ff6dfb972544b0f4a54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t pxarCore::GetADC </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rpc_par1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get ADC value </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l02222">2222</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5ccb6f5e5a02459ba7fa7ef9cb6d2a3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t pxarCore::getDACRange </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the valid range of a given DAC </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00619">619</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a011fa8ad63621ef87e78e341c598310d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; pxarCore::getEfficiencyMap </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to get a map of the efficiency</p>
<p>Returns a vector of pixels, with the value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct being the number of hits in that pixel. Efficiency == 1 for nhits == nTriggers</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01048">1048</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3347177376e2a7b9e55b68dfacd1d81b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; pxarCore::getEfficiencyVsDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a DAC range and measure the efficiency</p>
<p>Returns a vector of pairs containing set dac value and pixels, with the value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct being the number of hits in that pixel. Efficiency == 1 for nhits == nTriggers</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00733">733</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a3ae556094df8de36da8293aa7953e11e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; pxarCore::getEfficiencyVsDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a DAC range and measure the efficiency</p>
<p>Returns a vector of pairs containing set dac value and pixels, with the value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct being the number of hits in that pixel. Efficiency == 1 for nhits == nTriggers The dacStep parameter can be used to set the increment of the DAC scan, i.e. only sparsely scanning every nth DAC.</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00739">739</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a24b0b947be9ee0bedf0da497bca023a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; &gt; pxarCore::getEfficiencyVsDACDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac1name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac2name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a 2D DAC-Range (DAC1 vs. DAC2) and measure the efficiency</p>
<p>Returns a vector containing pairs of DAC1 values and pais of DAC2 values with a <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> vector. The value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct is the number of hits in that pixel. Efficiency == 1 for nhits == nTriggers</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00951">951</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab5c91b826614b1c1defd248097846ba8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; &gt; pxarCore::getEfficiencyVsDACDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac1name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac2name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a 2D DAC-Range (DAC1 vs. DAC2) and measure the efficiency</p>
<p>Returns a vector containing pairs of DAC1 values and pais of DAC2 values with a <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> vector. The value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct is the number of hits in that pixel. Efficiency == 1 for nhits == nTriggers The dacStep parameters can be used to set the increment of the DAC scan, i.e. only sparsely scanning every nth DAC. Increment can be set independently for both scanning dimensions.</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00957">957</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9de11051f5c0babffd3cdef948853012"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; pxarCore::getPulseheightMap </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to get a map of the pulse height</p>
<p>Returns a vector of pixels, with the value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct being the averaged pulse height over "nTriggers" triggers</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01024">1024</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a71995f1d7d7500cc4f8a9203b3de197a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; pxarCore::getPulseheightVsDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a DAC range and measure the pulse height</p>
<p>Returns a vector of pairs containing set dac value and a <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> vector, with the value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct being the averaged pulse height over "nTriggers" triggers.</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00675">675</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae8ac879718c4f5712c364ff1b06649bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; pxarCore::getPulseheightVsDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTrigger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a DAC range and measure the pulse height</p>
<p>Returns a vector of pairs containing set dac value and a <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> vector, with the value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct being the averaged pulse height over "nTriggers" triggers. The dacStep parameter can be used to set the increment of the DAC scan, i.e. only sparsely scanning every nth DAC.</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00681">681</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9377c701b65b5a4c33213519f84e3b6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; &gt; pxarCore::getPulseheightVsDACDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac1name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac2name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a 2D DAC-Range (DAC1 vs. DAC2) and measure the pulse height</p>
<p>Returns a vector containing pairs of DAC1 values and pais of DAC2 values with a <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> vector. The value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct is the averaged pulse height over "nTriggers" triggers.</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00878">878</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab13e60b7270ead9f8a2b450341fc7ccf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; &gt; pxarCore::getPulseheightVsDACDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac1name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac2name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a 2D DAC-Range (DAC1 vs. DAC2) and measure the pulse height</p>
<p>Returns a vector containing pairs of DAC1 values and pais of DAC2 values with a <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> vector. The value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct is the averaged pulse height over "nTriggers" triggers. The dacStep parameters can be used to set the increment of the DAC scan, i.e. only sparsely scanning every nth DAC. Increment can be set independently for both scanning dimensions.</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00884">884</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac5f32e86178f7b6141d0b8168dc6d0d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpxar_1_1statistics.html">statistics</a> pxarCore::getStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that returns a class object of the type <a class="el" href="classpxar_1_1statistics.html">pxar::statistics</a> containing all collected error statistics from the last (non-raw) DAQ readout or API test call. Statistics can be fetched once and are then reset. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00538">538</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a40a1071988d01e6ed626f0ad608d089e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double pxarCore::getTBia </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read out analog DUT supply current on the testboard The current will be returned in SI units of Ampere </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00424">424</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab7b001119e0e60dada88b18341d0ea5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double pxarCore::getTBid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read out digital DUT supply current on the testboard The current will be returned in SI units of Ampere </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00434">434</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a6419c0d917bee6cecb59f1e66589ab99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double pxarCore::getTBva </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read out analog DUT supply voltage on the testboard The voltage will be returned in SI units of Volts </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00429">429</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="acbcdd46ea90d929e56ed1b5269406158"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double pxarCore::getTBvd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read out digital DUT supply voltage on the testboard The voltage will be returned in SI units of Volts </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00439">439</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8318cc0578158041a0c43543dfb7e1a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; pxarCore::getThresholdMap </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to get a map of the pixel threshold</p>
<p>Returns a vector of pixels, with the value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct being the threshold value of that pixel.</p>
<p>This function allows to specify a range for the threshold DAC to be searched, this can be used to speed up the procedure by limiting the range. The dacStep parameter can be used to set the increment of the DAC scan, i.e. only sparsely scanning every nth DAC. The threshold value returned is the lower bound (upper bound for FLAG_RISING_EDGE) of the interval in which the true threshold is found.</p>
<p>The threshold is calculated as the 0.5 value of the s-curve of the pixel.</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01080">1080</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a97a94cd47a8305af37702cc605d2579d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; pxarCore::getThresholdMap </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacStep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacMax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to get a map of the pixel threshold</p>
<p>Returns a vector of pixels, with the value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct being the threshold value of that pixel.</p>
<p>This function allows to specify a range for the threshold DAC to be searched, this can be used to speed up the procedure by limiting the range. The dacStep parameter can be used to set the increment of the DAC scan, i.e. only sparsely scanning every nth DAC. The threshold value returned is the lower bound (upper bound for FLAG_RISING_EDGE) of the interval in which the true threshold is found.</p>
<p>The threshold can be adjusted to a percentage of efficienciy (i.e. threshold = 50 is the 50% efficiency niveau of the pixel).</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01086">1086</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab31ccce6a021b6520e7b357062e8ed57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; pxarCore::getThresholdMap </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to get a map of the pixel threshold</p>
<p>Returns a vector of pixels, with the value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct being the threshold value of that pixel.</p>
<p>The threshold is calculated as the 0.5 value of the s-curve of the pixel.</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l01072">1072</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a61e5089712a3c41e7588d852c2f2be6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; pxarCore::getThresholdVsDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac2name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a DAC range and measure the pixel threshold</p>
<p>Returns a vector of pairs containing set dac value and pixels, with the value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct being the threshold value of that pixel.</p>
<p>The threshold is calculated as the 0.5 value of the s-curve of the pixel.</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00789">789</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a9cfff2fc927e9be3af232e49d3bac511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; pxarCore::getThresholdVsDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac1name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac2name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a DAC range and measure the pixel threshold</p>
<p>Returns a vector of pairs containing set dac value and pixels, with the value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct being the threshold value of that pixel.</p>
<p>This function allows to specify a range for the threshold DAC to be searched, this can be used to speed up the procedure by limiting the range. The dacstep parameters can be used to set the increments of the 2D DAC scan, i.e. only sparsely scanning every nth DAC. The threshold value returned is the lower bound (upper bound for FLAG_RISING_EDGE) of the interval in which the true threshold is found. The increment can be set independently for both scanning dimensions.</p>
<p>The threshold is calculated as the 0.5 value of the s-curve of the pixel.</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00797">797</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a84d3638feb85989ab781de9210a44a27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; uint8_t, std::vector&lt; <a class="el" href="classpxar_1_1pixel.html">pixel</a> &gt; &gt; &gt; pxarCore::getThresholdVsDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac1name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac1max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dac2name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dac2max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nTriggers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Method to scan a DAC range and measure the pixel threshold</p>
<p>Returns a vector of pairs containing set dac value and pixels, with the value of the <a class="el" href="classpxar_1_1pixel.html">pxar::pixel</a> struct being the threshold value of that pixel.</p>
<p>This function allows to specify a range for the threshold DAC to be searched, this can be used to speed up the procedure by limiting the range. The dacstep parameters can be used to set the increments of the 2D DAC scan, i.e. only sparsely scanning every nth DAC. The threshold value returned is the lower bound (upper bound for FLAG_RISING_EDGE) of the interval in which the true threshold is found. The increment can be set independently for both scanning dimensions.</p>
<p>The threshold can be adjusted to a percentage of efficienciy (i.e. threshold = 50 is the 50% efficiency niveau of the pixel).</p>
<p>If the readout of the DTB is corrupt, a <a class="el" href="classpxar_1_1DataMissingEvent.html">pxar::DataMissingEvent</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00803">803</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a8ebf962f162ccc8334fe7abb469ae603"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string pxarCore::getVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the version string for the pxar API.</p>
<p>When using a git checkout the version number will be calculated at compile time from the latest tagged version plus the number of commits on top of that. In this case the version number also contains the commit hash of the latest commit for reference.</p>
<p>In case of a tarball install the version number is hardcoded in the CMakeLists.txt file. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00043">43</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac767ac2ab1365bfe06ee644521632210"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pxarCore::HVoff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>turn off HV </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00445">445</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a24431df2e62c79195cb1ff43a6c5ece1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pxarCore::HVon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>turn on HV </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00449">449</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a90558c993bd7f1a7bbf0211427fa1883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::initDUT </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hubId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tbmtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>tbmDACs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>roctype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>rocDACs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classpxar_1_1pixelConfig.html">pixelConfig</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>rocPixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt;&#160;</td>
          <td class="paramname"><em>rocI2Cs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializer method for the DUT (attached devices)</p>
<p>This function requires the types and DAC settings for all TBMs and ROCs contained in the setup. All values will be checked for validity (DAC ranges, position and number of pixels, etc.) and an <a class="el" href="classpxar_1_1InvalidConfig.html">pxar::InvalidConfig</a> exception is thrown if any errors are encountered.</p>
<p>All parameters are supplied via vectors, the size of the vector represents the number of devices. DAC names and device types should be provided as strings. The respective register addresses will be looked up internally. Strings are checked case-insensitive, old and new DAC names are both supported.</p>
<p>In case of USB communication problems, <a class="el" href="classpxar_1_1UsbConnectionError.html">pxar::UsbConnectionError</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00108">108</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a67c61cf0cf2622bb154dcc801f2f891c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::initDUT </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hubid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>tbmtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>tbmDACs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>roctype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>rocDACs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classpxar_1_1pixelConfig.html">pixelConfig</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>rocPixels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alternative initializer method for the DUT (attached devices).</p>
<p>As above, but automatically assumes consecutively numbered I2C addresses for all attached ROCs, starting from zero. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00098">98</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ac548bd5277822a2909ebf7bef6a0d43c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::initTestboard </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>sig_delays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string, double &gt; &gt;&#160;</td>
          <td class="paramname"><em>power_settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>pg_setup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializer method for the testboard</p>
<p>Initializes the testboard with signal delay settings, and voltage/current limit settings (power_settings) and the initial pattern generator setup (pg_setup), all provided via vectors of pairs with descriptive name. The name lookup is performed via the central API dictionaries. Multiple pattern generator signals at once can be sent by separating their names with a semicolon.</p>
<p>All user inputs are checked for sanity. This includes range checks on the current limits set, a sanity check for the pattern generator command list (including a check for delay = 0 at the end of the list). If the settings are found to be out-of-range, a <a class="el" href="classpxar_1_1InvalidConfig.html">pxar::InvalidConfig</a> exception is thrown.</p>
<p>In case of USB communication problems, <a class="el" href="classpxar_1_1UsbConnectionError.html">pxar::UsbConnectionError</a> is thrown. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00045">45</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a13f141e8cf927b697e405b2067809890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pxarCore::Poff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>turn off power </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00453">453</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a697061c7a1aa2896b2621e217f313bbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pxarCore::Pon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>turn on power </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00459">459</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae5d921d40a156d80066affb1a230c17a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::programDUT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Programming method for the DUT (attached devices)</p>
<p>This function requires the DUT structure to be filled (initialized).</p>
<p>All parameters are taken from the DUT struct, the enabled devices are programmed. This function needs to be called after power cycling the testboard output (using Poff, Pon).</p>
<p>A DUT flag is set which prevents test functions to be executed if not programmed. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00299">299</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="afbd230c972c6856940049ad719f29a9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pxarCore::SetCalibrateBits </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to setup the attached devices for operation using calibrate pulses.</p>
<p>It sets the Pixel Unit Cell (PUC) Calibrate bit for every pixels enabled in the test range (those for which the "enable" flag has been set using the <a class="el" href="classpxar_1_1dut.html#a08a6e724bd095b9142cf9c0701ca2a2d">dut::testPixel()</a> functions)</p>
<p>Disclaimer: use at your own risk, don't rely on this method staying public </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l02016">2016</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="afc60832fc9539864fd2f116d9343aa96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pxarCore::setClockStretch </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the clock stretch. FIXME missing documentation A width of 0 disables the clock stretch </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l02215">2215</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a13fad3782f3cd2f76acd6d9ae84e72d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::setDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rocI2C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a DAC value on the DUT for one specific ROC</p>
<p>The "rocID" parameter can be used to select a specific ROC to program. The ROC is identified by its ID (counting all ROCs up from 0).</p>
<p>This function will both update the bookkeeping value in the <a class="el" href="classpxar_1_1dut.html">pxar::dut</a> struct and program the actual device. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00546">546</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a27a7a90248e5ca1d21f39911242e22da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::setDAC </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dacName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dacValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a DAC value on the DUT for all enabled ROC</p>
<p>This function will both update the bookkeeping value in the <a class="el" href="classpxar_1_1dut.html">pxar::dut</a> struct and program the actual device. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00588">588</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="afd08a94f6d99b78a1e5a1f2ec87cbb9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::setExternalClock </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable the external clock source of the DTB. This function will return "false" if no external clock is present, clock is then left on internal. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l02188">2188</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a1a3f9fcc5e6de2cd2bd5ac48a9be78d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pxarCore::setPatternGenerator </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>pg_setup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update method for testboard pattern generator. This method requires the testboard to be initialized once using pxar::initTestboard All user inputs are checked for sanity. This includes a full sanity check for the pattern generator command list, including a check for the total pattern length supplied as well as the delay = 0 at the end of the list. If the settings are found to be out-of-range, a <a class="el" href="classpxar_1_1InvalidConfig.html">pxar::InvalidConfig</a> exception is thrown. The new settings are stored in the <a class="el" href="classpxar_1_1dut.html">pxar::dut</a> object for later reference. Multiple pattern generator signals at once can be sent by separating their names with a semicolon, e.g. "token;sync". </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00078">78</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a5e880c5e5f8a450bfe3a613b59b82fcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pxarCore::setSignalMode </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set Signal Mode. Define any testboard signal (e.g. clk) to the state constant high, constant low, or normal oscillation. signal: "clk", "ctr", "sda", or "tin" mode: 0 (normal), 1 (low) or 2 (high) </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l02204">2204</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ae4e6b5ff840d72ccc3bc3cead2b1ab2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::setTbmReg </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>regName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>tbmid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a register value on a specific TBM of the DUT</p>
<p>The "tbmid" parameter can be used to select a specific TBM to program. This function will both update the bookkeeping value in the <a class="el" href="classpxar_1_1dut.html">pxar::dut</a> struct and program the actual device.</p>
<p>This function will set the respective register in the TBM core specified by the "tbmid". Be aware of the fact that TBM Alpha cores are numbered with even IDs (0,2,...) and TBM Beta cores with odd IDs (1,3,...). </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00633">633</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="ab616074fb9f630d18ea8d2dba2900695"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::setTbmReg </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>regName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a register value on all TBMs of the DUT</p>
<p>This function will both update the bookkeeping value in the <a class="el" href="classpxar_1_1dut.html">pxar::dut</a> struct and program the actual device.</p>
<p>This function will set the respective register in the TBM core specified by the "tbmid". Be aware of the fact that TBM Alpha cores are numbered with even IDs (0,2,...) and TBM Beta cores with odd IDs (1,3,...). </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00667">667</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="aea2fffac45525dd53e6f1a211a8f106d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pxarCore::setTestboardDelays </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string, uint8_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>sig_delays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update method for testboard signal delay settings. This method requires the testboard to be initialized once using pxar::initTestboard All user inputs are checked for sanity. This includes a register name lookup and range checks on the register values. If the settings are found to be out-of-range, a <a class="el" href="classpxar_1_1InvalidConfig.html">pxar::InvalidConfig</a> exception is thrown. The new settings are stored in the <a class="el" href="classpxar_1_1dut.html">pxar::dut</a> object for later reference. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00068">68</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a090fd82d15bf7ac2a8db2e474e5ecb33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pxarCore::setTestboardPower </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string, double &gt; &gt;&#160;</td>
          <td class="paramname"><em>power_settings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update method for testboard voltages and current limits. This method requires the testboard to be initialized once using pxar::initTestboard All user inputs are checked for sanity. This includes range checks on the current limits set. If the settings are found to be out-of-range, a <a class="el" href="classpxar_1_1InvalidConfig.html">pxar::InvalidConfig</a> exception is thrown. The new settings are stored in the <a class="el" href="classpxar_1_1dut.html">pxar::dut</a> object for later reference. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00088">88</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a376f496a005202e06854393ada0d0cd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::SignalProbe </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>probe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects "signal" as output for the DTB probe channel "probe" (digital or analog). Valid probe values are the names written on the case of the DTB, next to the respective outputs.</p>
<p>The signal identifier is checked against a dictionary to be valid. In case of an invalid signal identifier the output is turned off. </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00465">465</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<a class="anchor" id="a080862f2b2c399fd09a13c8000daeff5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pxarCore::status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Status function for the API</p>
<p>Returns true if everything is setup correctly for operation </p>

<p>Definition at line <a class="el" href="api_8cc_source.html#l00339">339</a> of file <a class="el" href="api_8cc_source.html">api.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a3bbaa8cf5eb2bd76411e924952a2081e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpxar_1_1dut.html">dut</a>* pxar::pxarCore::_dut</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DUT object for book keeping of settings </p>

<p>Definition at line <a class="el" href="api_8h_source.html#l00728">728</a> of file <a class="el" href="api_8h_source.html">api.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>core/api/<a class="el" href="api_8h_source.html">api.h</a></li>
<li>core/api/<a class="el" href="api_8cc_source.html">api.cc</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 3 2015 10:03:51 for pxar by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
